================================================================================
FEATURE: MULTI-REACTION SYSTEM (UNLIMITED REACTIONS PER USER)
================================================================================
Date: December 27, 2025
Version: 2.0
Status: ‚úÖ COMPLETED
Author: Development Team

================================================================================
1. OVERVIEW
================================================================================

H·ªá th·ªëng reaction cho ph√©p users t∆∞∆°ng t√°c v·ªõi messages th√¥ng qua c√°c bi·ªÉu t∆∞·ª£ng
c·∫£m x√∫c (emoji reactions). Phi√™n b·∫£n 2.0 n√†y h·ªó tr·ª£:

‚úÖ M·ªói user c√≥ th·ªÉ th√™m NHI·ªÄU LO·∫†I reaction kh√°c nhau cho c√πng 1 message
‚úÖ S·ªë l∆∞·ª£ng m·ªói lo·∫°i reaction KH√îNG GI·ªöI H·∫†N (click nhi·ªÅu l·∫ßn = tƒÉng count)
‚úÖ Click v√†o reaction type ƒë√£ c√≥ ‚Üí GI·∫¢M count c·ªßa user ƒë√≥
‚úÖ Khi count = 0 ‚Üí T·ª± ƒë·ªông x√≥a reaction type c·ªßa user
‚úÖ Real-time sync qua WebSocket cho t·∫•t c·∫£ clients
‚úÖ Optimistic updates tr√™n UI

V√≠ d·ª•: User A c√≥ th·ªÉ:
- Click "heart" 3 l·∫ßn ‚Üí heart count = 3
- Click "haha" 2 l·∫ßn ‚Üí haha count = 2  
- Click "heart" l·∫°i ‚Üí heart count gi·∫£m xu·ªëng 2
- Click "heart" 2 l·∫ßn n·ªØa ‚Üí heart count = 0, reaction "heart" b·ªã x√≥a

================================================================================
2. DATA STRUCTURE
================================================================================

2.1. FIRESTORE DOCUMENT STRUCTURE
----------------------------------
messages/{messageId}/
  reactions: Map<userId, reactionType>
    - L∆∞u reaction type g·∫ßn nh·∫•t c·ªßa m·ªói user
    - Backward compatible v·ªõi version c≈©
    - Example: {"userA": "heart", "userB": "haha"}
  
  reactionsDetailed: Map<userId, Map<reactionType, count>>
    - Chi ti·∫øt ƒë·∫ßy ƒë·ªß v·ªÅ reactions c·ªßa m·ªói user
    - H·ªó tr·ª£ multiple reaction types v√† multiple counts
    - Example: {
        "userA": {"heart": 3, "haha": 2},
        "userB": {"heart": 1, "wow": 5}
      }
  
  reactionCounts: Map<reactionType, totalCount>
    - T·ªïng count c·ªßa m·ªói reaction type (sum t·∫•t c·∫£ users)
    - D√πng ƒë·ªÉ display s·ªë l∆∞·ª£ng tr√™n UI
    - Example: {"heart": 4, "haha": 2, "wow": 5}

2.2. MESSAGE MODEL (Android)
-----------------------------
public class Message {
    // Backward compatible - shows latest reaction per user
    private Map<String, String> reactions;
    
    // Detailed reactions - Map<userId, Map<reactionType, count>>
    private Map<String, Map<String, Object>> reactionsDetailed;
    
    // Total counts - Map<reactionType, totalCount>
    private Map<String, Integer> reactionCounts;
    
    // Getters/Setters...
}

2.3. CALCULATION LOGIC
----------------------
reactionCounts[type] = SUM of all reactionsDetailed[userId][type]

Example:
reactionsDetailed = {
  "userA": {"heart": 3, "haha": 2},
  "userB": {"heart": 1, "wow": 5}
}

‚Üí reactionCounts = {
  "heart": 4,   // 3 + 1
  "haha": 2,    // 2
  "wow": 5      // 5
}

================================================================================
3. API ENDPOINTS
================================================================================

3.1. ADD/REMOVE REACTION
------------------------
POST /api/chats/:conversationId/messages/:messageId/reactions

Request Body:
{
  "userId": "string",
  "reactionType": "string",  // "heart", "haha", "wow", "sad", "angry", "like"
  "action": "string"         // "add" or "remove"
}

Response (200 OK):
{
  "success": true,
  "message": "Reaction added/removed successfully",
  "data": {
    "conversationId": "string",
    "messageId": "string",
    "userId": "string",
    "reactionType": "string",
    "reactions": Map<String, String>,
    "reactionsDetailed": Map<String, Map<String, Object>>,
    "reactionCounts": Map<String, Integer>
  }
}

LOGIC:
------
action = "add":
  1. Increment reactionsDetailed[userId][reactionType]
  2. Update reactions[userId] = reactionType (latest)
  3. Recalculate reactionCounts
  4. Save to Firestore
  5. Broadcast via WebSocket

action = "remove":
  1. Decrement reactionsDetailed[userId][reactionType]
  2. If count <= 0: Delete reactionsDetailed[userId][reactionType]
  3. If no reactions left: Delete reactionsDetailed[userId]
  4. Update reactions[userId] to other reaction type (if exists)
  5. Recalculate reactionCounts
  6. Save to Firestore
  7. Broadcast via WebSocket

================================================================================
4. WEBSOCKET EVENTS
================================================================================

4.1. SERVER TO CLIENT: reaction_updated
----------------------------------------
Event: "reaction_updated"

Payload:
{
  "conversationId": "string",
  "messageId": "string",
  "userId": "string",           // User who triggered the action
  "reactionType": "string",     // Reaction type affected
  "reactions": Map<String, String>,
  "reactionsDetailed": Map<String, Map<String, Object>>,
  "reactionCounts": Map<String, Integer>
}

Broadcast to: All clients in room "conversation:{conversationId}"

4.2. CLIENT HANDLING
--------------------
1. Receive event via SocketManager
2. Find message in cached list by messageId
3. Update message.reactions, message.reactionsDetailed, message.reactionCounts
4. Create deep copy of message list
5. Notify UI via LiveData
6. DiffUtil detects changes
7. RecyclerView updates affected items

================================================================================
5. CLIENT IMPLEMENTATION (Android)
================================================================================

5.1. REPOSITORY LAYER (ChatRepository.java)
--------------------------------------------
// Add reaction (increment count)
public void addReaction(String conversationId, String messageId, 
                       String reactionType, ResponseCallback callback)

// Remove reaction (decrement count)  
public void decrementReaction(String conversationId, String messageId,
                              String reactionType, ResponseCallback callback)

// Toggle reaction (smart logic)
public void toggleReaction(String conversationId, String messageId,
                          String currentUserId, String reactionType,
                          ResponseCallback callback)

TOGGLE LOGIC:
-------------
Map<String, Object> userReactions = reactionsDetailed.get(currentUserId);

if (userReactions != null && userReactions.containsKey(reactionType)) {
    // User ƒë√£ c√≥ reaction n√†y ‚Üí REMOVE (decrement)
    decrementReaction(conversationId, messageId, reactionType, callback);
} else {
    // User ch∆∞a c√≥ reaction n√†y ‚Üí ADD (increment)
    addReaction(conversationId, messageId, reactionType, callback);
}

5.2. VIEWMODEL LAYER (RoomViewModel.java)
------------------------------------------
public void addReaction(String messageId, String reactionType) {
    chatRepository.addReaction(conversationId, messageId, reactionType, callback);
}

public void decrementReaction(String messageId, String reactionType) {
    chatRepository.decrementReaction(conversationId, messageId, reactionType, callback);
}

public void toggleReaction(String messageId, String reactionType) {
    chatRepository.toggleReaction(conversationId, messageId, currentUserId,
                                  reactionType, callback);
}

5.3. UI LAYER (RoomActivity.java)
----------------------------------
private void handleReactionClick(String messageId, String reactionType) {
    Log.d(TAG, "handleReactionClick - messageId: " + messageId 
              + ", reactionType: " + reactionType);
    
    // Use toggleReaction for smart add/remove logic
    viewModel.toggleReaction(messageId, reactionType);
}

5.4. ADAPTER (MessageAdapter.java)
-----------------------------------
CRITICAL: Prevent shared reference issues

// Store DEEP COPY of messages to prevent external modification
this.messages = new java.util.ArrayList<>();
for (Message msg : filteredMessages) {
    this.messages.add(new Message(msg)); // Deep copy each message
}

// Create DEEP COPY for DiffUtil comparison
List<Message> oldMessages = new java.util.ArrayList<>();
for (Message msg : this.messages) {
    oldMessages.add(new Message(msg)); // Deep copy each message
}

WHY DEEP COPY?
--------------
1. ChatRepository modifies cachedMessages directly
2. If adapter holds references to same objects ‚Üí DiffUtil won't detect changes
3. Deep copy ensures adapter has immutable snapshot
4. DiffUtil can properly compare old vs new states

5.5. MESSAGE COPY CONSTRUCTOR
------------------------------
public Message(Message other) {
    // ... copy all fields ...
    
    // CRITICAL: Deep copy reactions maps
    this.reactions = other.reactions != null 
        ? new java.util.HashMap<>(other.reactions) : null;
    
    this.reactionCounts = other.reactionCounts != null 
        ? new java.util.HashMap<>(other.reactionCounts) : null;
    
    // Deep copy reactionsDetailed (nested map)
    if (other.reactionsDetailed != null) {
        this.reactionsDetailed = new java.util.HashMap<>();
        for (Map.Entry<String, Map<String, Object>> entry : other.reactionsDetailed.entrySet()) {
            this.reactionsDetailed.put(entry.getKey(), 
                new java.util.HashMap<>(entry.getValue()));
        }
    }
}

================================================================================
6. FLOW DIAGRAMS
================================================================================

6.1. ADD REACTION FLOW
----------------------
User clicks reaction ‚Üí RoomActivity.handleReactionClick()
  ‚Üì
RoomViewModel.toggleReaction(messageId, reactionType)
  ‚Üì
ChatRepository checks reactionsDetailed
  ‚Üì
Determine action: add or remove
  ‚Üì
[ACTION = ADD]
  ‚Üì
ChatRepository.addReaction() ‚Üí API POST with action="add"
  ‚Üì
Server: Increment count in Firestore
  ‚Üì
Server: Broadcast reaction_updated via WebSocket
  ‚Üì
All clients receive event
  ‚Üì
SocketManager ‚Üí OnReactionListener ‚Üí ChatRepository
  ‚Üì
Update cachedMessages ‚Üí Create deep copy
  ‚Üì
Notify LiveData observers
  ‚Üì
RoomActivity observer ‚Üí adapter.updateMessages()
  ‚Üì
DiffUtil.calculateDiff() detects changes
  ‚Üì
RecyclerView updates item

6.2. REMOVE REACTION FLOW  
-------------------------
User clicks existing reaction ‚Üí RoomActivity.handleReactionClick()
  ‚Üì
RoomViewModel.toggleReaction(messageId, reactionType)
  ‚Üì
ChatRepository checks reactionsDetailed ‚Üí reaction exists
  ‚Üì
[ACTION = REMOVE]
  ‚Üì
ChatRepository.decrementReaction() ‚Üí API POST with action="remove"
  ‚Üì
Server: Decrement count in Firestore
  ‚Üì
If count = 0: Remove from reactionsDetailed
  ‚Üì
Server: Broadcast reaction_updated via WebSocket
  ‚Üì
[Same as ADD flow from WebSocket onwards]

6.3. WEBSOCKET SYNC FLOW
-------------------------
Device A adds reaction
  ‚Üì
Server broadcasts to room "conversation:{id}"
  ‚Üì
Device B (in same conversation) receives event
  ‚Üì
SocketManager parses JSON
  ‚Üì
Extract: conversationId, messageId, userId, reactionType,
         reactions, reactionsDetailed, reactionCounts
  ‚Üì
Call reactionListener.onReactionUpdated()
  ‚Üì
ChatRepository finds message in cachedMessages
  ‚Üì
Create NEW maps (to avoid reference issues):
  - newReactions = new HashMap(reactions)
  - newReactionCounts = new HashMap(reactionCounts)
  - newReactionsDetailed = deep copy of reactionsDetailed
  ‚Üì
Update message with new maps
  ‚Üì
Create deep copy list for UI
  ‚Üì
Post to main thread ‚Üí Notify LiveData
  ‚Üì
UI updates via DiffUtil

================================================================================
7. SERVER IMPLEMENTATION (Node.js)
================================================================================

7.1. API ENDPOINT (server/src/routes/chats.js)
-----------------------------------------------
router.post('/:conversationId/messages/:messageId/reactions', async (req, res) => {
    const { conversationId, messageId } = req.params;
    const { userId, reactionType, action } = req.body; // action: "add" or "remove"
    
    const messageRef = db.collection('conversations')
        .doc(conversationId)
        .collection('messages')
        .doc(messageId);
    
    const messageDoc = await messageRef.get();
    const messageData = messageDoc.data();
    
    let reactions = messageData.reactions || {};
    let reactionsDetailed = messageData.reactionsDetailed || {};
    let reactionCounts = messageData.reactionCounts || {};
    
    if (action === 'add') {
        // Increment count
        if (!reactionsDetailed[userId]) reactionsDetailed[userId] = {};
        reactionsDetailed[userId][reactionType] = 
            (reactionsDetailed[userId][reactionType] || 0) + 1;
        
        // Update latest reaction
        reactions[userId] = reactionType;
        
    } else if (action === 'remove') {
        // Decrement count
        if (reactionsDetailed[userId] && reactionsDetailed[userId][reactionType]) {
            reactionsDetailed[userId][reactionType]--;
            
            // Remove if count <= 0
            if (reactionsDetailed[userId][reactionType] <= 0) {
                delete reactionsDetailed[userId][reactionType];
            }
            
            // Remove user if no reactions left
            if (Object.keys(reactionsDetailed[userId]).length === 0) {
                delete reactionsDetailed[userId];
                delete reactions[userId];
            } else {
                // Update to another reaction type
                const remainingTypes = Object.keys(reactionsDetailed[userId]);
                reactions[userId] = remainingTypes[0];
            }
        }
    }
    
    // Recalculate total counts
    reactionCounts = {};
    for (const [uid, userReactions] of Object.entries(reactionsDetailed)) {
        for (const [type, count] of Object.entries(userReactions)) {
            reactionCounts[type] = (reactionCounts[type] || 0) + count;
        }
    }
    
    // Save to Firestore
    await messageRef.update({
        reactions,
        reactionsDetailed,
        reactionCounts
    });
    
    // Broadcast via WebSocket
    io.to(`conversation:${conversationId}`).emit('reaction_updated', {
        conversationId,
        messageId,
        userId,
        reactionType,
        reactions,
        reactionsDetailed,
        reactionCounts
    });
    
    res.json({ success: true, data: { ... } });
});

7.2. WEBSOCKET HANDLER (server/src/websocket/index.js)
-------------------------------------------------------
// Room management for conversations
socket.on('join_conversation', (conversationId) => {
    socket.join(`conversation:${conversationId}`);
    socket.emit('room_joined', { 
        conversationId, 
        success: true 
    });
});

// Broadcast happens automatically in API endpoint using:
io.to(`conversation:${conversationId}`).emit('reaction_updated', payload);

================================================================================
8. UI DISPLAY LOGIC
================================================================================

8.1. REACTION DISPLAY
---------------------
For each message:
  - Show reaction buttons: ‚ù§Ô∏è üòÇ üòÆ üò¢ üò† üëç
  - Display count badge: ‚ù§Ô∏è 5  üòÇ 3
  - Highlight if current user has that reaction
  - Show detailed list on long press (optional)

8.2. CURRENT USER HIGHLIGHT
----------------------------
Map<String, Object> currentUserReactions = 
    message.getReactionsDetailed().get(currentUserId);

if (currentUserReactions != null && 
    currentUserReactions.containsKey("heart")) {
    // Highlight heart button
    heartButton.setSelected(true);
    // Show count
    int count = (Integer) currentUserReactions.get("heart");
    heartButton.setText("‚ù§Ô∏è " + count);
}

8.3. REACTION DETAILS DIALOG (Future Enhancement)
--------------------------------------------------
Show list of users and their reaction counts:
- John: ‚ù§Ô∏è x3, üòÇ x2
- Mary: ‚ù§Ô∏è x1, üòÆ x5
- Bob: üëç x1

================================================================================
9. TESTING SCENARIOS
================================================================================

9.1. SINGLE USER MULTI-REACTION
--------------------------------
‚úÖ User A clicks "heart" ‚Üí count = 1
‚úÖ User A clicks "heart" again ‚Üí count = 2
‚úÖ User A clicks "heart" again ‚Üí count = 3
‚úÖ User A clicks "haha" ‚Üí heart = 3, haha = 1
‚úÖ User A clicks "heart" again (remove) ‚Üí count = 2
‚úÖ User A clicks "heart" 2 more times ‚Üí count = 0, removed

9.2. MULTI-USER SYNC
--------------------
‚úÖ Device A: User A adds heart ‚Üí Device B sees update
‚úÖ Device B: User B adds heart ‚Üí Device A sees update
‚úÖ Device A: User A removes heart ‚Üí Device B sees update
‚úÖ Total count updates correctly across all devices

9.3. EDGE CASES
---------------
‚úÖ Add reaction when offline ‚Üí Optimistic update ‚Üí Sync when online
‚úÖ Remove reaction that doesn't exist ‚Üí Graceful handling
‚úÖ Rapid clicks ‚Üí Queue requests, no race conditions
‚úÖ Empty reactions ‚Üí Display nothing, no errors

================================================================================
10. PERFORMANCE CONSIDERATIONS
================================================================================

10.1. OPTIMISTIC UPDATES
-------------------------
- UI updates immediately before API response
- If API fails, revert to previous state
- Prevents UI lag

10.2. DEEP COPY STRATEGY
------------------------
- Only copy when needed (on data change)
- Use efficient HashMap copy constructors
- Avoid unnecessary object creation

10.3. DIFFUTIL EFFICIENCY
--------------------------
- Only compares visible items
- Animates only changed items
- Prevents full RecyclerView refresh

10.4. WEBSOCKET ROOMS
---------------------
- Each conversation has own room
- Only users in conversation receive updates
- Reduces unnecessary network traffic

================================================================================
11. MIGRATION FROM V1 TO V2
================================================================================

11.1. BACKWARD COMPATIBILITY
-----------------------------
‚úÖ Old clients still see `reactions` map (single reaction per user)
‚úÖ New clients use `reactionsDetailed` for full functionality
‚úÖ Server maintains both fields during transition

11.2. DATA MIGRATION
--------------------
Existing messages with old reaction format:
{
  "reactions": {"userA": "heart", "userB": "like"}
}

Auto-convert on first access:
{
  "reactions": {"userA": "heart", "userB": "like"},
  "reactionsDetailed": {
    "userA": {"heart": 1},
    "userB": {"like": 1}
  },
  "reactionCounts": {"heart": 1, "like": 1}
}

================================================================================
12. FUTURE ENHANCEMENTS
================================================================================

12.1. CUSTOM REACTIONS
----------------------
- Allow users to add custom emoji
- Store in user preferences
- Sync across devices

12.2. REACTION ANIMATIONS
-------------------------
- Animate reaction count changes
- Show who reacted (avatars fly up)
- Haptic feedback on click

12.3. REACTION STATISTICS
-------------------------
- Most used reaction per user
- Conversation reaction trends
- Export reaction analytics

12.4. REACTION NOTIFICATIONS
----------------------------
- Notify when someone reacts to your message
- Group similar notifications
- Smart notification batching

================================================================================
13. TROUBLESHOOTING
================================================================================

13.1. REACTIONS NOT SYNCING
----------------------------
Check:
- WebSocket connection status
- User is in correct room (conversation:{id})
- Server broadcasting to correct room
- Client listener registered

Debug:
- Enable debug logs in SocketManager
- Check server logs for broadcast events
- Verify conversationId matches

13.2. DIFFUTIL NOT DETECTING CHANGES
-------------------------------------
Check:
- Deep copy is being used in adapter
- Message copy constructor copies all maps
- No shared references between old and new lists

Debug:
- Log oldReactions vs newReactions in DiffCallback
- Verify object references are different
- Check if maps are properly copied

13.3. COUNT MISMATCH
--------------------
Check:
- reactionCounts calculation is correct
- No concurrent modification issues
- All clients using same calculation logic

Debug:
- Compare reactionsDetailed vs reactionCounts
- Verify sum matches across all users
- Check for race conditions on rapid clicks

================================================================================
14. RELATED DOCUMENTATION
================================================================================

- 22_feature_message-reactions.txt (V1 implementation)
- 31_audit_direct-db-access-analysis.txt (API migration context)
- 33_phase2-backend-api-completed.txt (API architecture)
- WebSocket documentation in server/README.md
- Message model documentation in app/src/main/java/com/example/doan_zaloclone/models/

================================================================================
END OF DOCUMENTATION
================================================================================
